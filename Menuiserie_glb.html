<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Configurateur Menuiserie Babylon.js</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; }
    canvas { width: 100%; height: 100%; display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 10px;
      z-index: 1;
      font-family: sans-serif;
    }
    label { display: block; margin-top: 5px; }
  </style>
</head>
<body>
  <div id="ui">
    <label>Largeur (mm): <input type="number" id="width" value="1200"></label>
    <label>Hauteur (mm): <input type="number" id="height" value="2150"></label>
  </div>
  <canvas id="renderCanvas"></canvas>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.9, 0.9, 0.95);

    const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 3 + Math.PI, Math.PI / 3, 5, BABYLON.Vector3.Zero(), scene);
    camera.attachControl(canvas, true);

    camera.wheelPrecision = 20;
    camera.lowerRadiusLimit = 1.5;
    camera.upperRadiusLimit = 20;

    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
    light.intensity = 1.5;

    const directionalLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(0, -1, 1), scene);
    directionalLight.intensity = 0.7;

    BABYLON.SceneLoader.ImportMesh(
  null,
  "https://jjgodard-itc.github.io/menuiserie/",
  "Menuiserie.glb",
  scene,
  function (meshes) {
    console.log("GLB chargé :", meshes);

    // Lancer la première génération du modèle après chargement
    updateModel();

    // Écouteurs pour les interactions UI
    document.querySelectorAll("#ui input, #ui select").forEach(el => {
      el.addEventListener("change", updateModel);
    });
  },
  null,
  function (scene, message) {
    console.error("Erreur de chargement :", message);
  }
);

    function updateModel() {
  const width = parseFloat(document.getElementById("width").value);
  const height = parseFloat(document.getElementById("height").value);
  const addAllege = document.getElementById("addAllege").checked;
  const allegeHeight = parseFloat(document.getElementById("allegeHeight").value);
  const addImposte = document.getElementById("addImposte").checked;
  const imposteHeight = parseFloat(document.getElementById("imposteHeight").value);

  // Nettoyer les anciens éléments (traverses et montants)
  const nomsASupprimer = [
    "Traverse_haut", "Traverse_bas", "Montant_gauche", "Montant_droite",
    "Traverse_allège", "Traverse_imposte"
  ];
  nomsASupprimer.forEach(name => {
    const node = scene.getTransformNodeByName(name);
    if (node) node.dispose();
  });

  // Traverse haute
  createTraverseHorizontale(width, height / 2 - 25, "haut");

  // Traverse basse
  createTraverseHorizontale(width, -height / 2 + 25, "bas");

  // Montants gauche et droite
  createMontantVertical(height, -width / 2 + 25, "gauche");
  createMontantVertical(height, width / 2 - 25, "droite");

  // Allège
  if (addAllege) {
    createTraverseHorizontale(width, -height / 2 + allegeHeight + 25, "bas");
  }

  // Imposte
  if (addImposte) {
    createTraverseHorizontale(width, height / 2 - imposteHeight - 25, "haut");
  }
}


    function createTraverseHorizontale(width, positionY, sens = "haut") {
  const container = new BABYLON.TransformNode(`Traverse_${sens}`, scene);

  const allMeshes = scene.meshes;

  const extG = allMeshes.find(m => m.name.includes(`${sens}`) && m.name.includes("Ext_G"));
  const extD = allMeshes.find(m => m.name.includes(`${sens}`) && m.name.includes("Ext_D"));
  const segment = allMeshes.find(m => m.name.includes(`${sens}`) && m.name.includes("Segment"));

  if (!extG || !extD || !segment) {
    console.error(`Composants de traverse ${sens} non trouvés`);
    return container;
  }

  const extSize = 50;
  const segSize = 100;

  const nbSegments = Math.floor((width - 2 * extSize) / segSize);
  const remainder = (width - 2 * extSize) - nbSegments * segSize;
  const startX = -width / 2 + extSize;

  const eg = extG.clone(`ExtG_${sens}`);
  eg.parent = container;
  eg.position.x = -width / 2 + extSize / 2;

  const ed = extD.clone(`ExtD_${sens}`);
  ed.parent = container;
  ed.position.x = width / 2 - extSize / 2;

  for (let i = 0; i < nbSegments; i++) {
    const s = segment.clone(`Segment_${sens}_${i}`);
    s.parent = container;
    s.position.x = startX + i * segSize + segSize / 2;
  }

  if (remainder > 1) {
    const last = segment.clone(`Segment_${sens}_reste`);
    last.parent = container;
    last.position.x = startX + nbSegments * segSize + remainder / 2;
    last.scaling.x = remainder / segSize;
  }

  container.position.y = positionY;
  return container;
}

function createMontantVertical(height, positionX, sens = "gauche") {
  const container = new BABYLON.TransformNode(`Montant_${sens}`, scene);

  const montant = scene.meshes.find(m => m.name.includes(sens) && m.name.includes("Segment"));
  if (!montant) {
    console.error(`Modèle de montant ${sens} non trouvé`);
    return container;
  }

  const montantClone = montant.clone(`MontantClone_${sens}`);
  montantClone.parent = container;
  montantClone.scaling.z = height / montantClone.getBoundingInfo().boundingBox.extendSize.z;
  montantClone.position.y = height / 2;

  container.position.x = positionX;
  return container;
}


    // Mise à jour à chaque changement de valeur
    document.getElementById("width").addEventListener("input", updateModel);
    document.getElementById("height").addEventListener("input", updateModel);

    document.querySelectorAll("#ui input, #ui select").forEach(el => {
  el.addEventListener("change", updateModel);
});


    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
